<!DOCTYPE html>
<html lang="en">
<head>

	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>Document</title>

	<script src="../libs/gsap/gsap.min.js" defer></script>
	<script src="../libs/gsap/ScrollTrigger.min.js" defer></script>
	<script src="../libs/gsap/ScrollSmoother.min.js" defer></script>

	<link rel="stylesheet" href="../css/gitlab.css">
	<script src="../js/gitlab.js" defer></script>

</head>
<body>

	<div class="wrapper">
		<div class="content">

			<header class="hero-section">
				<img data-speed=".6" class="hero" src="../assets/images/gitlab/gitlab-logo-500.png" alt="Alt" >
				<div class="container">
					<div data-speed=".75" class="main-header">
						<h1 class="main-title">GitLab</h1>
					</div>
				</div>
			</header>
		
			<div class="portfolio">
				<div class="container">
					<main class="gallery">
	<!-- Левый столбец -->
						<div data-speed=".9" class="gallery__left">
				
							<img width=1400 class="gallery__item" src="/assets/images/gitlab/tagesflow.png" alt="Alt">
							
							<div class="text-block gallery__item">
								<h2 class="text-block__h">Функциональность</h2>
								<p class="text-block__p"> <b>Схлопнем коммиты</b>.</p>
								<br>
								<p class="text-block__p">Зачастую, наши мелкие коммиты по типу "покрасил кнопку в красный" помогают ревьюерам и теряют ценность когда необходимо вливать пулреквест. Для этого мы можем легко схлопнуть их в один целостный понятный коммит.</p>
								<br>
								<p class="text-block__p">Для начала, используем команду <b>git cherry -v master</b> которая покажет разницу между текущей веткой и мастером. В результате увидим 6 коммитов, которые мы схлопнем в один</p>
								<br>
								<p class="test-block__p">Перепишем историю с момента 6 коммитов назад, используем команду <b>git rebase -i HEAD~6</b> i - в данном случаем интерактивный режим.</p>
								<br>
								<p class="test-block__p">Тут видим доступные команды, но нас интересует команда <b>squash</b>, заменяем 5 строк после первой с <b>pick</b> на <b>squash</b> и сохраняемся.</p>
								<br>
								<p class="test-block__p">Удаляем лишние комменты, оставляем один первый.</p>
							</div>

							<img class="gallery__item" src="/assets/images/gitlab/gitint.png" alt="Alt">
		
							<img class="gallery__item" src="../assets/images/gitlab/squashpush.png" alt="Alt">
							
							<img class="gallery__item" src="../assets/images/gitlab/gittet.png" alt="Alt">

							<div class="text-block gallery__item">
								<h2 class="text-block__h">Займемся черешней</h2>
								<p class="text-block__p">Для начала, необходимо узнать какой именно коммит будем переносить. Для этого воспользуемся командой <b>git cherry -v master</b>, находясь в ветке <b>pages</b>.</p>
								<br>
								<p class="text-block__p">Узнав идентификатор, переходим на мастер ветку (куда будем перемещать наш коммит) <b>git checkout master</b> прописываем команду переноса <b>git cherry-pick</b> и вставляем идентификатор нашего коммита.</p>
								<br>
								<p class="text-block__p">В результате проверим, что коммит находится на нужной ветке, при этом, идентификатор переписался, так как по сути, является новые для данной ветки, это надо учитывать.</p>
							</div>
		
							<img class="gallery__item" src="../assets/images/gitlab/resultcherry.png" alt="Alt">

							<img class="gallery__item" src="../assets/images/gitlab/gitsubmodulefirst.png" alt="gitsubmodulefirst">

							<img class="gallery__item" src="../assets/images/gitlab/gitsubmoduledown.png" alt="gitsubmoduledown">

							<div class="text-block gallery__item">
								<h2 class="text-block__h">Проблема выбора удаленного репозитория</h2>
								<p class="text-block__p">Удаленные репозитории являются версиями наших локальных проектов и их может быть несколько, в зависимости от рабочего процесса. Для просмотра количество и адрес подключенных репозиториев достаточно ввести <b>git remote -v</b>. Однако, если клонировать репозиторий тут уже по умолчанию будет удаленная мастер ветка исходного проекта.</p>
							</div>

							<img class="gallery__item" src="../assets/images/gitlab/gitremoteadd.png" alt="gitremoteadd">

						</div>
<!-- Правый столбец -->
						<div data-speed="1.1" class="gallery__right">
		
							<div class="text-block gallery__item">
								<h2 class="text-block__h">GitFlow</h2>
								<p class="text-block__p"><b>Gitflow</b> — это популярная методология управления ветками в Git, разработанная Винсентом Дриссеном. Она помогает упорядочить процесс разработки, предоставляя четкие правила для создания и слияния веток.</p>
								<br>
								<p class="text-block__p">Основные элементы Gitflow:</p>
								<br>
								<p class="text-block__p">Основные ветки: <br> <b>main</b>(master): стабильная версия, готовая для выпуска; <br> <b>develop</b>: последняя версия кода с новыми функциями и исправлениями, предназначенная для тестирования.</p>
								<br>
								<p class="text-block__p">Поддерживающие ветки: <br> <b>feature</b> создаются для разработки новых функций. Ветви feature создаются от develop и после завершения сливаются обратно в develop; <br> <b>release</b>: используются для подготовки новой версии. Ветви release создаются от develop и после завершения сливаются в main и develop; <br> <b>hotfix</b>: предназначены для экстренного исправления багов в main. Ветви hotfix создаются от main и после завершения сливаются в main и develop.</p>
								<br>
								<p class="text-block__p">Основной принцип Gitflow — четкое разделение кода на этапы разработки, тестирования и релиза, что облегчает совместную работу и управление проектом.</p>
								<br>
								<h2 class="text-block__h">Gitlog</h2>
								<br>
								<p class="test-block__p">Для просмотра истории коммитов достаточно использовать команду <b>git log</b> <br> Добавив флаг <b>-p</b> можно увидеть разницу (выводит патч), внесённую в каждый коммит.</p>
								<img class="gallery__item" src="../assets/images/gitlab/gitlog.png"Alt">
							</div>

							<img class="gallery__item" src="../assets/images/gitlab/gitcommits.png"Alt">

							<img class="gallery__item" src="../assets/images/gitlab/gitcomments.png"Alt">



							<div class="text-block gallery__item">
								<p class="text-block__p">Попробуем запушить (<b>git push</b>) изменения в ветку. Но сейчас это не удастся. </p>
								<br>
								<p class="text-block__p">Это потому, что ваша локальная ветка и ветка на сервере отличаются. Причём не просто в локальной ветке есть некоторые коммиты, которых нет на сервере, но и старых коммитов нет. Ведь теперь один новый коммит вместо всех прежних. Чтобы запушить на сервер все изменения, несмотря на конфликт, запустим пуш с флагом --force: <b>git push --force</b></p>
								<br>
								<p class="test-block__p">И посмотреть список коммитов</p>
							</div>

							<div class="text-block gallery__item">
								<h2 class="text-block__h">Cherry pick</h2>
								<br>
								<p class="text-block__p"><b>git cherry-pick</b> — это полезная команда, с помощью которой можно выборочно применить коммиты Git к текущей рабочей ветке HEAD</p>
								<br>
								<p class="text-block__p">Применима в командной разработке, когда новая функция продукта включает компоненты серверной и клиентской части, две составляющие продукта используют общий код или когда разработчик серверной части создает структуру данных, которую нужно будет использовать и в клиентской части. При этом разработчик клиентской части может с помощью команды git cherry-pick выбрать коммит, в котором условная структура данных была создана. Таким образом, он сможет продолжить работу над своими проектными задачами.</p>
								<br>
								<p class="text-block__p">Или, при исправлениие багов. В ходе работы обнаруживается существующий баг, и разработчик создает специальный коммит для его исправления. Этот коммит можно перенести прямо в основную ветку (main), чтобы исправить баг, прежде чем от него пострадают другие пользователи.</p>
							</div>

							<img class="gallery__item" src="../assets/images/gitlab/cherrysha.png" alt="Alt">

							<img class="gallery__item" src="../assets/images/gitlab/mastercherry.png" alt="Alt">


							<div class="text-block gallery__item">
								<h2 class="text-block__h">Git - модули</h2>
								<br>
								<p class="text-block__p">Git решает проблему с синхронизацией изменений и использованием сторонних библиотек и собственной кодовой базы внутри проекта при их копировании. Подмодули позволяют сохранить один Git-репозиторий, как подкаталог другого Git-репозитория. Это даёт вам возможность клонировать в проект другой репозиторий, но коммиты при этом хранить отдельно.</p>
								<br>
								<p class="text-block__p">Для начала, необходимо в репозитории создать файл <b>.submodules</b> и укзаать путь, куда будут попадать бинарники импортируемой библиотеке. Разберем на примере репозиторий с документацией, где в качестве сабмодуля выступает стороння тема для <b>HUGO</b>.</p>
								<br>
								<p class="text-block__p">Далее, необходимо выполнить две команды, чтобы подсказать репозиторию о необходимости обозначения и загрузки подгружаемой библиотеке</p>
								<img class="gallery__item" src="../assets/images/gitlab/gitsubmodulecommands.png" alt="gitsubmodulecommands">
							</div>
		
							<div class="text-block gallery__item">
								<p class="text-block__p">В итоге, получаем библиотеку, загруженную в заданную папку в репозитории, готовой к использованию.</p>
							</div>

							<img class="gallery__item" src="../assets/images/gitlab/gitremote.png" alt="Alt">

							<div class="text-block gallery__item">
								<p class="text-block__p">Допустим, мы хотим получить какие-то данные с другого репозитория, для этого воспользуемся командой <b>git remote add new https://github.com/mooncyclone/blueberryEventHorizon</b>, где <b>git remote add</b> -  команда по добавлению репозитория, <b>new</b> - название нового репозитория и адрес.</p>
								<br>
								<p class="text-block__p">Проверим теперь сколько подключено репозиториев. Теперь можем использовать новый репозиторий для получения данных <b>git fetch new</b>.</p>
							</div>

							<div class="text-block gallery__item">
								<h2 class="text-block__h">Чистый репозиторий?</h2>
								<p class="text-block__p">Как и <b>git init --bare</b>, аргумент <b>-bare</b> при назначении команде git clone приводит к созданию копии удаленного репозитория без рабочего каталога. Это означает, что репозиторий будет содержать историю проекта, к которой можно выполнять запросы <b>push</b> и <b>pull</b>, но которую нельзя редактировать напрямую.</p>
								<br>
								<p class="text-block__p">Кроме того, в репозитории, клонированном с опцией <b>-bare</b>, не будут настроены удаленные ветки. Как и <b>git init --bare</b>, эта команда создает удаленный репозиторий, который разработчики не смогут редактировать напрямую.</p>
							</div>

						</div>

					</main>
				</div>
			</div>

		</div>
	</div>

</body>
</html>